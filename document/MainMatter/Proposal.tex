\chapter{Propuesta}\label{chapter:proposal}
En este capítulo se presenta la aplicación propuesta para resolver problemas de optimización a partir de una interfaz lingüística.
Permitiendo a un usuario común modelar y resolver problemas prácticos, a partir de una simple descripción en lenguaje natural.
En base al estudio bibliográfico realizado se optó por una solución que combine modelos de lenguaje junto a herramientas externas.
Debido a que esta estrategia es la más utilizada en el estado del arte, proporcionando el mejor rendimiento en cuanto a resolver problemas de optimización.


También se proponen los siguientes pasos para el siguiente proceso de solución de un problema de optimización:
\begin{itemize}
  \item Extracción y refinamiento de la descripción del problema a partir de la intera-cción con el usuario.
  \item Modelación del problema.
  \item Generación de código a partir del modelo.
  \item Ejecución del código y obtención de resultados.
\end{itemize}
Además de los pasos de modelación, generación de código y ejecución que son usados ampliamente en las soluciones presentadas en el estado del arte, se incluye un paso adicional, donde se interactúa con el usuario para obtener una descripción del problema.
Este paso está diseñado para evitar en su mayoría los problemas de ambigüedad e información incompleta en la descripción del problema, que podrían presentarse debido a la inexperiencia del usuario.


La solución emplea una arquitectura multi-agente como las presentadas en algunos trabajos en el capítulo anterior.
Se utiliza un sistema centralizado, donde existe un agente central o supervisor como núcleo de la aplicación, que se encarga de controlar todo el proceso de solución del problema.
Este agente tiene la capacidad de delegar tareas específicas a otros agentes y validar la correctitud de sus respuestas. Este proceso se ilustra de forma general en la figura~\ref{fig: architecture}.


\begin{figure}[h]
  \centering
  \makebox[\textwidth][c]{
    \includegraphics[width=1.2\textwidth]{proposal.png}
  }
  \caption{Arquitectura propuesta}
  \label{fig: architecture}
\end{figure}

El diseño de la solución inlcuye la posibilidad de resolver una amplia variedad de problemas de optimización, incluyendo:
\begin{itemize}
  \item Problemas de Programación Lineal (LP)
  \item Problemas de Programación Lineal Entera Mixta (MILP)
  \item Problemas de Programación No Lineal (NLP)
  \item Problemas de Programación No Lineal Entera Mixta (MINLP)
  \item Problemas de Satisfacción de Restricciones (CSP)
\end{itemize}

También se incluye una vía alternativa para resolver problemas usando metaheurísticas y métodos aproximados.
Permitiendo así la posibilidad de tratar problemas complejos que poseen un gran número de variables con resultados y tiempos de ejecución aceptables.


\section{Modelación}
Para modelar los problemas de optimización se utilizó una estructura específica montada sobre un formato \textit{JSON}.
Esta estructura se denominó \textit{FNP} y se diseñó combinando conceptos como la modelación de los cinco elementos (\cite{jiang2025llmopt}) y modelación sobre estructuras formales como el formato \textit{JSON}.
A continuación se muestra una descripción de toda la información que se extrae para generar un modelo a partir de la descripción de un problema de optimización en lenguaje natural:

\begin{itemize}
  \item \textbf{Tipo de problema:} Califica el problema en LP, MILP, NLP, MINLP, CS\@.
  \item \textbf{Tipo específico:} Este campo se utiliza para clasificar problemas específicos que tienden a presentar mayor complejidad como problemas de planificación, o de enrutamiento, etc.
  \item \textbf{Tiempo:} El tiempo límite para resolver el problema especificado por el usuario.
  \item \textbf{Conjuntos:} Los conjuntos de un problema de optimización son agrupaciones de elementos relacionados, que son relevantes para la formulación de variables y restricciones (ej: las diferentes ciudades de un país, los diferentes tipos de un producto, etc).
  \item \textbf{Parámetros:} Los parámetros de un problema son datos estáticos relevantes para la modelación de este, pueden ser datos únicos o datos que dependan de elementos de un conjunto.
  \item \textbf{Variables:} En este campo se modelan todo el conjunto de variables del problema. De cada variable se almacena el tipo (entera o continua), el dominio de la variable y su contexto en el problema, es decir que representa esa variable. También es posible modelar una variable por cada elemento de un conjunto, o escalarlo y modelar una variable por cada combinación de elementos de dos o más conjuntos distintos.
  \item \textbf{Restricciones:} De cada restricción se almacenan su tipo (linear o no linear), su contexto en el problema y su formulación matemática. Esta formulación matemática debe referenciar a las variables y parámetros antes declarados en el modelo del problema.
  \item \textbf{Restricciones especiales:} Algunas restricciones presentan una formulación un poco más compleja, ya que no entran en las clasificaciones clásicas como lineares o no lineales (ej: todas las variables deben ser diferentes, o deben haber al menos n variables con valor k, etc). Estas restricciones especiales se modelan en este campo.
  \item \textbf{Función objetivo:} En este campo se almacena la función objetivo del problema, su sentido (maximización o minimización), su tipo (linear o no linear), su contexto en el problema y su formulación matemática.
\end{itemize}

Se escogió esta vía para modelar los problemas de optimización por varias razones.
Primero, como se mencionó anteriormente, la formulación de los cinco elementos facilita a los modelos de lenguaje el entendimiento del problema, mejorando su efectividad al trabajar con problemas de optimización.
Esta formulación permite no solo guardar metadatos del problema, sino que también combina en una misma modelación las expresiones matemáticas con el contexto de cada componente del modelo.
Usar el formato \textit{JSON} permite modelar formalmente el problema, tal que no solo los modelos pueden entender y analizar el problema, sino que también se puede validar la estructura del modelo y sus componentes de forma automática, así como extraer información del problema como su tipo, el tiempo límite, el tamaño del problema teniendo en cuenta la cantidad de variables y restricciones.


\subsection{Ejemplo de Modelación}
A continuación se muestran dos ejemplos de modelos \textit{FNP} generados a partir de descripciones en lenguaje natural de problemas de optimización.
\paragraph{Problema 1:}

Glueco has 5 different production lines for glue. He needs to assign workers to each production line.
On production line 1, each worker produces 20 units of glue 1, 30 units of glue 2, and 40 units of glue 3 during a hour.
On production line 2, each worker produces 50 units of glue 1, 35 units of glue 2, and 45 units of glue 3 during a hour.
On production line 3, each worker produces 30 units of glue 1, 40 units of glue 2, and 50 units of glue 3 during a hour.
On production line 4, each worker produces 40 units of glue 1, 45 units of glue 2, and 50 units of glue 3 during a hour.
On production line 5, each worker produces 25 units of glue 1, 35 units of glue 2, and 45 units of glue 3 during a hour.
Now, Glueco needs to produce at least 120 units of glue 1, at least 150 units of glue 2, and at least 200 units of glue 3.
The five production lines can only be opened or closed at the same time. Please determine the minimum time to meet the weekly demand.
There are total 80 workers available. Each line can be utilized by up to 20 workers at a time. Glueco produces 3 types of glue on the 5 production lines.



\paragraph{Problema 2:}

There are six cities (cities 1-6) in Kilroy County. The county must determine where to build fire stations. The county wants to build the minimum number of fire stations needed to ensure that at least one fire station is within 15 minutes (driving time) of each city. The times (in minutes) required to drive between the cities in Kilroy County are shown in the following Table. Formulate a linear problem that will tell Kilroy how many fire stations should be built and where they should be located.
Table (Time Required to Travel between Cities in Kilroy County):

\begin{table}[h]
  \centering
  \begin{tabular}{ccccccc}
    \toprule
    \textbf{From / To} & \textbf{City 1} & \textbf{City 2} & \textbf{City 3} & \textbf{City 4} & \textbf{City 5} & \textbf{City 6} \\
    \midrule
    \textbf{City 1}    & 0               & 10              & 20              & 30              & 30              & 20              \\
    \midrule
    \textbf{City 2}    & 10              & 0               & 25              & 35              & 20              & 10              \\
    \midrule
    \textbf{City 3}    & 20              & 25              & 0               & 15              & 30              & 20              \\
    \midrule
    \textbf{City 4}    & 30              & 35              & 15              & 0               & 15              & 25              \\
    \midrule
    \textbf{City 5}    & 30              & 20              & 30              & 15              & 0               & 14              \\
    \midrule
    \textbf{City 6}    & 20              & 10              & 20              & 25              & 14              & 0               \\
    \bottomrule
  \end{tabular}
  \caption{Time Required to Travel between Cities in Kilroy County}
  \label{tab:travel-times}

\end{table}


\subsubsection*{FNP 1:}


\begin{lstlisting}[language=json, caption={Modelo FNP del problema 1.}, label={lst:fnp1}]
    {
        "type": "MINLP",
        "specific_type": "NONE",
        "time": 1000,
        "sets": {
            "production_lines": {
                "description": "The different production lines available at Glueco.",
                "elements": [
                    "line_1",
                    "line_2",
                    "line_3",
                    "line_4",
                    "line_5"
                ]
            },
            "glue_types": {
                "description": "The different types of glue produced.",
                "elements": [
                  "glue_1",
                  "glue_2",
                  "glue_3"
                ]
            }
        },
        "parameters": {
            "production_rate": {
                "description": "Units of a specific glue type produced per worker per hour on each production line.",
                "values": {
                  "line_1": {
                    "glue_1": 20,
                    "glue_2": 30,
                    "glue_3": 40
                  },
                  "line_2": {
                    "glue_1": 50,
                    "glue_2": 35,
                    "glue_3": 45
                  },
                  "line_3": {
                    "glue_1": 30,
                    "glue_2": 40,
                    "glue_3": 50
                  },
                  "line_4": {
                    "glue_1": 40,
                    "glue_2": 45,
                    "glue_3": 50
                  },
                  "line_5": {
                    "glue_1": 25,
                    "glue_2": 35,
                    "glue_3": 45
                  }
                }
            },
            "min_demand": {
              "description": "Minimum required units for each type of glue.",
              "values": {
                "glue_1": 120,
                "glue_2": 150,
                "glue_3": 200
              }
            },
            "total_workers_available": {
              "description": "Total number of workers available across all production lines.",
              "value": 80
            },
            "max_workers_per_line": {
              "description": "Maximum number of workers that can be assigned to a single production line.",
              "value": 20
            }
        },
        "variables": {
          "time_to_produce": {
            "description": "The total time (in hours) required to meet the weekly demand.",
            "type": "real",
            "domain": {
              "lower_bound": 0,
              "upper_bound": null
            },
            "index": []
          },
          "workers_on_line": {
            "description": "Number of workers assigned to each production line.",
            "type": "integer",
            "domain": {
              "lower_bound": 0,
              "upper_bound": 20
            },
            "index": [
              "production_lines"
            ]
          }
        },
        "constrains": {
          "total_workers_limit": {
            "description": "The total number of workers assigned to all production lines cannot exceed the total available workers.",
            "type": "linear",
            "expression": "sum_{j in production_lines} workers_on_line[j] <= total_workers_available"
          },
          "glue_demand_satisfaction": {
            "description": "The total production of each glue type must meet its minimum required demand.",
            "type": "nonlinear",
            "expression": "sum_{j in production_lines} production_rate[j][g] * workers_on_line[j] * time_to_produce >= min_demand[g] for all g in glue_types"
          },
          "line_worker_capacity": {
            "description": "Each production line can be utilized by a maximum number of workers.",
            "type": "linear",
            "expression": "workers_on_line[j] <= max_workers_per_line for all j in production_lines"
          }
        },
        "special_constraints": {},
        "objective": {
          "description": "Minimize the total time required to meet the weekly demand for all glue types.",
          "sense": "minimize",
          "expression": "time_to_produce"
        }
    }
    
\end{lstlisting}


\subsubsection*{FNP 2:}

\begin{lstlisting}[language=json, caption={Modelo FNP del problema 2.}, label={lst:fnp2}]
    {
      "type": "MILP",
      "specific_type": "NONE",
      "time": 1000,
      "sets": {
        "cities": {
          "description": "The set of cities in Kilroy County.",
          "elements": [
            "1",
            "2",
            "3",
            "4",
            "5",
            "6"
          ]
        }
      },
      "parameters": {
        "travel_time": {
          "description": "Time required to travel between cities in Kilroy County (in minutes). travel_time[i][j] is the time from city i to city j.",
          "values": {
            "1": {
              "1": 0,
              "2": 10,
              "3": 20,
              "4": 30,
              "5": 30,
              "6": 20
            },
            "2": {
              "1": 10,
              "2": 0,
              "3": 25,
              "4": 35,
              "5": 20,
              "6": 10
            },
            "3": {
              "1": 20,
              "2": 25,
              "3": 0,
              "4": 15,
              "5": 30,
              "6": 20
            },
            "4": {
              "1": 30,
              "2": 35,
              "3": 15,
              "4": 0,
              "5": 15,
              "6": 25
            },
            "5": {
              "1": 30,
              "2": 20,
              "3": 30,
              "4": 15,
              "5": 0,
              "6": 14
            },
            "6": {
              "1": 20,
              "2": 10,
              "3": 20,
              "4": 25,
              "5": 14,
              "6": 0
            }
          }
        },
        "max_travel_time": {
          "description": "The maximum allowed driving time (in minutes) from a city to a fire station for it to be considered covered.",
          "value": 15
        }
      },
      "variables": {
        "build_station": {
          "description": "Binary variable, 1 if a fire station is built in city i, 0 otherwise.",
          "type": "binary",
          "domain": {
            "lower_bound": 0,
            "upper_bound": 1
          },
          "index": [
            "cities"
          ]
        }
      },
      "constrains": {
        "city_coverage": {
          "description": "Ensures that each city is within the maximum allowed travel time of at least one fire station.",
          "type": "linear",
          "expression": "for j in cities: sum_{i in cities | travel_time[i][j] <= max_travel_time} build_station[i] >= 1"
        }
      },
      "special_constraints": {},
      "objective": {
        "description": "Minimize the total number of fire stations built.",
        "sense": "minimize",
        "expression": "sum_{i in cities} build_station[i]"
      }
    }
\end{lstlisting}



\section{Arquitectura Multi-Agente}
En esta sección abordaremos en detalle cada uno de los agentes que componen la arquitectura de la solución propuesta.
Se profundizará en los roles y tareas de cada agente y como contribuyen a la solución final.
\subsection{Agente Conversacional}\label{subsec:conv-agent}
La primera capa de la solución propuesta es un agente encargado de hacer de interfaz lingüística con el usuario. Este agente tiene tres funciones principales:
\begin{itemize}
  \item Como primera y principal tarea, se encarga de interactuar con el usuario para obtener una descripción del problema. Al asumir que el usuario puede no poseer conocimientos sobre optimización matemática, existe la posibilidad de que la descripción inicial del problema sea incompleta o ambigua. Por ello, el agente debe ser capaz de identificar posibles lagunas en la información proporcionada y formular preguntas adicionales para aclarar y completar los detalles necesarios del problema.
  \item Cuando el agente considera que no existe una potencial información faltante en la descripción del problema, se encarga de construir una descripción detallada y refinada del problema a partir de su conversación con el usuario. Además se instruye al agente a modificar la información del problema para hacerla más explícita y entendible. Este proceso incluye la estandarización de las terminologías usadas, incluir cualquier información implícita del problema en la descripción del problema (ej: naturaleza de las variables, restricciones de sentido común, etc).
  \item Cuando se resuelve el problema de optimización, este agente debe tomar los resultados del problema y elaborar una respuesta en lenguaje natural para el usuario, donde le explique el proceso de solución y los resultados que se obtuvieron.
\end{itemize}


\subsection{Agente Supervisor}
El agente supervisor es el centro de esta arquitectura, con la tarea de controlar todo el flujo de solución del problema.
Este flujo se podría describir de la siguiente manera: el agente recibe la descripción ya refinada del problema y ordena al agente de modelación que genere el modelo \textit{FNP}.
A partir del modelo generado, el agente supervisor analiza las características del problema, en especial su tipo y tamaño.
Esta información, le permite determinar que vía de solución debe tomar el agente generador de código.
Una vez que el código es generado el agente supervisor es el encargado de ejecutarlo, y en caso de que se lance un error en tiempo de ejecución, debe proporcionarle retroalimentación al agente de generación de código para que corrija los errores, entrando en un ciclo de corrección hasta que se ejecute correctamente.
Luego de obtener los resultados, el agente supervisor debe realizar un análisis evaluando la correctitud de estos, lo que le permite decidir si los resultados están listos para devolverlos al usuario, o por el contrario, los resultados no parecen tener sentido y es necesario revisar el modelo.


\subsection{Agentes de Modelado y Generación de Código}
Cada uno de estos agentes solo tiene una tarea específica: generar el modelo o el código respectivamente, bajo las instrucciones y configuraciones dictadas por el agente supervisor.
Además cada uno es responsable de hacer validaciones indispensables sobre la salida que generan, y deben corregir cualquier error encontrado.
Por ejemplo: el agente de modelado luego de generar el \textit{FNP} del problema debe validar que esté sintácticamente correcto, conteniendo todas las llaves necesarias.










