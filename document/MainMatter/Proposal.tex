\chapter{Propuesta}\label{chapter:proposal}
En este trabajo se presenta una propuesta de aplicación para resolver problemas de optimización a partir de una interfaz lingüística.
Se emplea una arquitectura multi-agente como las que se mostraron en el capítulo anterior para procesar el lenguaje natural, y a partir de este modelar el problema.
Esta arquitectura utiliza un sistema centralizado, donde existe un agente central que delega tareas específicas a otros agentes, como se muestra en la figura \ref{fig: architecture}.


\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{architecture.png}
    \caption{Arquitectura propuesta}
    \label{fig: architecture}

\end{figure}

El diseño incluye varios métodos para validar y manejar errores, con el objetivo de mitigar las alucinaciones cometidos por los modelos de lenguaje. Entre ellos podemos mencionar la retroalimentación usando los errores en tiempo de ejecución, para corregir el código generado, o el análisis reflexivo de la modelación del problema.
A partir de las opciones de modelación que se exponen en el estado del arte, se generó una estructura de modelado formal pero que permite mantener un vínculo de cada cláusula con su contexto, así como almacenar metadatos del problema. Otra de las carácteristicas que posee esta propuesta es la posibilidad de manejar distintos tipos de problemas de optimización intregando distintas herramientas y solucionadores en el entorno.
Esto permite tomar diferentes cursos de acciones en base a si es un problema de programación lineal, programación entera o satisfacción de restricciones. Un detalle a tener en cuenta es que se tiene en cuenta un tiempo límite establecido por el usuario para resolver el problema. Este límite también modifica la estrategia de solución del problema, influyendo en si se utilzan enfoques no exactos pero más rápidos para resolver el problema, en caso de que el margen de tiempo sea pequeño. O en caso de que no sea un problema, utilizar métodos exactos que garantizen la mejor solución.


\subsection*{Agente Conversacional}
La primera capa de la solución propuesta es un agente que se encarga de hacer de interfaz lingüística con el usuario. Con este agente se intenta suplir la falta de conocimiento o experticia de los usuarios, al intentar solucionar problemas prácticos.
La principal tarea de este agente es analizar el problema planteado por el usuario, y valorar potencial información faltante. Si considera que podría no haberse proporcionado algún dato escencial referente al problema, se encarga de formular una serie de preguntas
para que el usuario conteste. Esto permite que el usuario pueda proveer la información necesaria para resolver el problema, sin necesidad de conocer cúal información es necesaria o no.
Una vez recopilada toda la información pertinente, el agente la consolida en una descripción estructurada en lenguaje natural. A continuación, esta descripción es sometida a un proceso de refinamiento, donde se instruye al modelo, mediante el uso de ejemplos (few-shot prompting),
para que transforme el texto e incremente su nivel de explicitud. Este proceso incluye la estandarización de la terminología, la inserción de anotaciones sobre la naturaleza de las variables y la conversión de expresiones coloquiales a su equivalente lógico-matemático (p. ej., transformar
“x no puede superar y” en “x es menor o igual que y”). Como parte de esta investigación, se evaluará la influencia de esta transformación en la eficacia del sistema para modelar correctamente los problemas, buscando así validar la hipótesis de que un mayor grado de explicitud en la formulación
del problema potencia significativamente la capacidad de razonamiento de los Grandes Modelos de Lenguaje.

\subsection*{Modelación}
Para modelar el problema de optimización se optó por una estructura específica, utilizar un formato \textit{JSON}, presentada como \textbf{FNP}.
Se utilizó como base \textit{Structured Natural Language Optimization}(\textit{SNOP}) \cite{ahmaditeshnizi2023optimusoptimizationmodelingusing}, un formato usado para almacenar problemas de optimización de manera estructurada.
Esta estructura permite almacenar metadatos del problema, así como mantener una relación entre la formalidad del problema y su contexto.
Al utilizar un formato \textit{JSON}, se facilita el manejo de esta modelación por lenguajes de programación así como por los modelos de lenguaje.
A continuación se muestran los campos y detalles de la estructura propuesta:

\begin{itemize}
    \item \textbf{Tipo de problema:} Califica el problema según en LP (programación lineal), MILP (programación lineal entera mixta), NLP (programación no lineal), MINLP (programación no lineal entera mixta), CS (satisfacción de restricciones).
    \item \textbf{Tipo específico:} Este campos se utiliza para clasificar problemas más complejos y específicos como planificación, enrutamiento, etc. Para el resto de problemas este campo estará vacío.
    \item \textbf{Tiempo:} El tiempo límite para resolver el problema especificado por el usuario.
    \item \textbf{Conjuntos:} Aquí se almacenan conjuntos de elementos, sobre los cuales es posible iterar en el problema, por ejemplo: las diferentes ciudades de un país, los diferentes tipos de un producto, etc.
    \item \textbf{Parámetros:} Los parámetros de un problema son datos estáticos relevantes para la modelación de este, pueden ser datos únicos o datos que dependan de elementos de un conjunto.
    \item \textbf{Variables:} En este campo se modelan todo el conjunto de variables del problema. De cada variable se almacena el tipo(entera o continua), el dominio de la variable. También es posible modelar una variable por cada elemento de un conjunto de forma iterativao escalarlo creando una variable por cada par de elementos de conjuntos distintos, o aún mas. Esto es posible usando un campo llamado \textit{index} dentro de la variable, que denota el o los conjuntos sobre los que se deben iterar.
    \item \textbf{Restricciones:} De cada restricción se almacenan su tipo(linear o no linear) y su formulación matemática, que referencia a las variables y parámetros antes declarados.
\end{itemize}


En cada declaración de cláusulas o entidades en esta estructura se mantiene una descripción de la variable en lenguaje natural, con el objetivo de mantener el contexto del problema en la modelación. Un ejemplo completo de esta estructura de modelado puede encontrarse en el anexo \ref{}


\subsection*{Detalles de implementación}


\subsubsection{Interfaz gráfica}
Como parte de la solución se desarrolló una interfaz gráfica web utilizando el framework \textit{Next.js}. Esta interfaz permite al usuario interactuar con la aplicación a través de una conversación, ingresando los detalles del problema y recibiendo retroalimentación.



\subsubsection{Modelos de lenguaje}
En el plano de la implementación, se emplearon los Grandes Modelos de Lenguaje (LLM) \textit{Gemini 2.0 Flash} y \textit{Gemini 2.5 Pro}. La selección de estos modelos, desarrollados por Google, se fundamentó en un criterio pragmático: la disponibilidad de una Interfaz de Programación de Aplicaciones (API) con un nivel de acceso gratuito, lo cual fue un factor determinante para la viabilidad del proyecto.
Estos LLM constituyen el motor computacional de los agentes de modelación y de generación de código. El criterio para emplear un modelo u otro se establece en función de la complejidad de la tarea: el modelo más ágil y económico se asigna a las operaciones de menor dificultad, mientras que el de mayor capacidad se reserva para aquellos procesos que demandan un razonamiento más avanzado.

\subsubsection{Julia}
Como lenguaje de programación para modelar y resolver el problema se escogió Julia. Un lenguaje de programación de alto rendimiento diseñado para la computación técnica y científica.
Se escogió este lenguaje por las siguientes ventajas que ofrece:
\begin{itemize}
    \item Posee un paquete de modelado de optimización llamado \textit{JuMP}, con una sintaxis declarativa que permiten definir variables y restricciones muy similar a una modelación teórica.
    \item Integración sencilla con numerosas herramientas de optimización y soluciona-dores (Ipopt, NLopt, Cbc, HiGHS, SCIP, etc) a través de un paquete llamado \textit{MathOptInterface}.
    \item Compilación Just-In-Time (JIT) sobre LLVM, que proporciona velocidad comparable a C/Fortran en fases de solución y en evaluaciones repetidas de modelos grandes.
    \item Diferenciación automática integrada (ForwardDiff, ReverseDiff), para obtener gradientes y Hessianas exactas en problemas no lineales sin código manual adicional.
\end{itemize}
Dada la amplia gama de problemas que la solución propuesta es capaz de abordar, se ha implementado una arquitectura modular basada en cuatro entornos de ejecución de Julia independientes. El propósito de esta segmentación es aislar las bibliotecas y dependencias específicas para cada categoría de problema, una práctica recomendada para prevenir conflictos e incompatibilidades entre paquetes de software.
Estos entornos se han especializado de la siguiente manera:
\begin{itemize}
    \item Programación Lineal y Entera Mixta: Un entorno dedicado a problemas de Programación Lineal (LP) y Lineal Entera Mixta (MILP).
    \item Programación no Lineal y Entera Mixta: Un segundo entorno para problemas de Programación no Lineal (NLP) y no Lineal Entera Mixta (MINLP).
    \item Satisfacción de Restricciones: Un tercer entorno especializado en Problemas de Satisfacción de Restricciones (CS, por sus siglas en inglés, Constraint Satisfaction).
    \item Metaheurísticas: Finalmente, un cuarto entorno que agrupa un conjunto de herramientas basadas en metaheurísticas. Este último está diseñado para la resolución aproximada y eficiente de problemas de alta complejidad, donde se prioriza la rapidez en la obtención de una solución de alta calidad por sobre la garantía de optimalidad.
\end{itemize}

\subsection*{Agente Supervisor}
El Agente Supervisor constituye el núcleo de la arquitectura de la solución propuesta, siendo responsable de la orquestación y ejecución del flujo de trabajo completo. Su función principal es coordinar el proceso, delegando tareas específicas a los agentes subordinados: el Agente de Modelación \textit{fnp} y el Agente de Generación de Código.
Una vez que el problema ha sido modelado, el Agente Supervisor procede a validar y analizar dicho modelo para identificar sus características clave, tales como el tipo, tamaño y complejidad del problema de optimización. Con base en este análisis, selecciona el conjunto de herramientas y estrategias más adecuadas, decidiendo sobre el solucionador (solver) compatible, el entorno de ejecución óptimo y otros componentes necesarios para la resolución.
Tras esta fase de planificación, el Agente Supervisor instruye al Agente de Generación de Código para que produzca el código fuente en Julia. La elección de este lenguaje presenta un desafío inherente: al ser relativamente menos popular, los Grandes Modelos de Lenguaje (LLM) tienden a mostrar un rendimiento inferior en la generación de su código, debido a la escasez de datos de entrenamiento disponibles, tal como se menciona en \cite{cassano2024knowledgetransferhighresourcelowresource}. Para mitigar esta desventaja, durante la fase de generación de código se le provee al LLM una serie de ejemplos cuidadosamente diseñados. Se ha desarrollado un conjunto de prompts específicos, cada uno enfocado en demostrar y explicar las diferentes sintaxis para programar componentes del modelo de optimización, como variables, restricciones y funciones objetivo.
Posteriormente, el Agente Supervisor ejecuta el código generado en el entorno previamente configurado y captura la salida. Esta salida puede corresponder a los resultados del problema o, en su defecto, a un error arrojado durante la ejecución. En caso de error, se inicia un ciclo iterativo de depuración: el Agente Supervisor retroalimenta al Agente de Generación de Código con el mensaje de error, solicitándole que corrija el código para solventar el fallo. Este proceso se repite hasta que el programa se ejecute con éxito o se alcance un número máximo predefinido de intentos.
El propósito fundamental de este mecanismo de revisión y corrección automatizada es reducir la incidencia de errores derivados de las "alucinaciones" del modelo de lenguaje. Esta estrategia resulta particularmente crucial en el contexto de Julia, un lenguaje donde, como se ha mencionado, el riesgo de que un LLM genere código incorrecto o inexistente es considerablemente mayor.